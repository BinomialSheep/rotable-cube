<html>
  <head>
    <meta charset="utf-8" />
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.167.0/build/three.module.js"
        }
      }
    </script>
    <script type="module">
      import * as THREE from "three";

      // サイズを指定
      const width = 960;
      const height = 540;

      // レンダラーを作成
      const renderer = new THREE.WebGLRenderer({
        canvas: document.querySelector("#myCanvas"),
      });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(width, height);
      renderer.setClearColor(0xcccccc); // 背景は薄いグレー

      // シーンを作成
      const scene = new THREE.Scene();

      // カメラを作成
      const camera = new THREE.PerspectiveCamera(45, width / height);
      camera.position.set(0, 0, +1000);

      // 面ごとの色を指定
      const materials = [
        new THREE.MeshBasicMaterial({ color: 0xff0000 }), // 赤
        new THREE.MeshBasicMaterial({ color: 0xffa500 }), // オレンジ
        new THREE.MeshBasicMaterial({ color: 0xffffff }), // 白
        new THREE.MeshBasicMaterial({ color: 0xffff00 }), // 黄
        new THREE.MeshBasicMaterial({ color: 0x00ff00 }), // 緑
        new THREE.MeshBasicMaterial({ color: 0x0000ff }), // 青
      ];

      // 箱を作成
      const geometry = new THREE.BoxGeometry(400, 400, 400);
      const box = new THREE.Mesh(geometry, materials);
      scene.add(box);

      // エッジを作成して追加
      const edges = new THREE.EdgesGeometry(geometry);
      const lineMaterial = new THREE.LineBasicMaterial({ color: 0x000000 }); // 黒色のライン
      const lineSegments = new THREE.LineSegments(edges, lineMaterial);
      box.add(lineSegments);

      // 面のテキスト
      const faceLabels = ["1", "2", "3", "4", "5", "6"];
      const facePositions = [
        new THREE.Vector3(0, 0, 200), // 前面
        new THREE.Vector3(0, 0, -200), // 背面
        new THREE.Vector3(0, 200, 0), // 上面
        new THREE.Vector3(0, -200, 0), // 下面
        new THREE.Vector3(200, 0, 0), // 右面
        new THREE.Vector3(-200, 0, 0), // 左面
      ];
      const faceRotations = [
        new THREE.Euler(0, 0, 0),
        new THREE.Euler(0, Math.PI, 0),
        new THREE.Euler(-Math.PI / 2, 0, 0),
        new THREE.Euler(Math.PI / 2, 0, 0),
        new THREE.Euler(0, Math.PI / 2, 0),
        new THREE.Euler(0, -Math.PI / 2, 0),
      ];
      const offset = 10; // ラベルがめり込まないように若干浮かせる

      // ラベル作成用関数
      const createLabelMesh = (text, width, height, fontSize) => {
        const canvas = document.createElement("canvas");
        canvas.width = width;
        canvas.height = height;
        const context = canvas.getContext("2d");
        context.font = `${fontSize}px Arial`;
        context.fillStyle = "black";
        context.textAlign = "center";
        context.textBaseline = "middle";
        context.fillText(text, width / 2, height / 2);

        const texture = new THREE.CanvasTexture(canvas);
        const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true, side: THREE.DoubleSide });
        const geometry = new THREE.PlaneGeometry(width, height);
        return new THREE.Mesh(geometry, material);
      };

      faceLabels.forEach((label, i) => {
        const labelMesh = createLabelMesh(label, 400, 200, 100);
        labelMesh.position.copy(facePositions[i]);
        labelMesh.rotation.copy(faceRotations[i]);
        if (i == 0) labelMesh.position.z += offset;
        if (i == 1) labelMesh.position.z -= offset;
        if (i == 2) labelMesh.position.y += offset;
        if (i == 3) labelMesh.position.y -= offset;
        if (i == 4) labelMesh.position.x += offset;
        if (i == 5) labelMesh.position.x -= offset;
        box.add(labelMesh);
      });

      let isDragging = false;
      let previousMousePosition = { x: 0, y: 0 };

      document.addEventListener("mousedown", () => (isDragging = true));
      document.addEventListener("mouseup", () => (isDragging = false));
      document.addEventListener("mousemove", (event) => {
        if (isDragging) {
          const deltaMove = {
            x: event.offsetX - previousMousePosition.x,
            y: event.offsetY - previousMousePosition.y,
          };
          const deltaRotationQuaternion = new THREE.Quaternion().setFromEuler(
            new THREE.Euler(toRadians(deltaMove.y), toRadians(deltaMove.x), 0, "XYZ")
          );
          box.quaternion.multiplyQuaternions(deltaRotationQuaternion, box.quaternion);
        }

        previousMousePosition = { x: event.offsetX, y: event.offsetY };
      });

      const toRadians = (angle) => angle * (Math.PI / 180);

      const animate = () => {
        renderer.render(scene, camera);
        requestAnimationFrame(animate);
      };

      animate();
    </script>
  </head>
  <body>
    <canvas id="myCanvas"></canvas>
  </body>
</html>
